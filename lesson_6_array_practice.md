# Массивы

Массив (в некоторых языках программирования также таблица, ряд, матрица, вектор) — структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу или набору индексов, принимающих целые (или приводимые к целым) значения из некоторого заданного непрерывного диапазона. Одномерный массив можно рассматривать как реализацию абстрактного типа данных — вектор.

Размерность массива — это количество индексов, необходимое для однозначной адресации элемента в рамках массивы. По количеству используемых индексов массивы делятся на одномерные, двумерные, трёхмерные и т. д.

Форма или структура массива — сведения о количестве размерностей и размере (протяжённости) массива по каждой из размерностей; может быть представлена одномерным массивом.

Особенностью массива как структуры данных (в отличие, например, от связного списка) является константная вычислительная сложность доступа к элементу массива по индексу. Массив относится к структурам данных с произвольным доступом.

В простейшем случае массив имеет константную длину по всем размерностям и может хранить данные только одного, заданного при описании, типа. Ряд языков поддерживает также динамические массивы, длина которых может изменяться по ходу работы программы, и гетерогенные массивы, которые могут в разных элементах хранить данные различных типов.

В строго типизированных ЯП есть четкое разделение на массивы(array) и словари(dictionary)
В чем разница? Разница в том что массив - некая коннечная последовательность определенных типов данных, наприимер последовательность целых чисел.
Словарь - ассоциативная последовательность ключ - значение, например список синонимов.

С точки зрения PHP массивы это одновременно и массив и словарь, так же массивы в PHP не имеют границ т.е могут расширятся динамически

Массив можно представить как некий шкаф с ящичками в которых каждый ящичек пронумерован. 
Нумерация массива всегда **начинается с 0!**
![array](images/objects-tenElementArray.gif)

## Синтаксис

### Нумерованные массивы

В PHP  обьявление массива начинается с **[]** при чем мы можем в начале обьявить как пустой массив так и предопределить элементы

```php 

$emptyArray = []; // пустой массив
$array = ['a', 'b', 'c']; // массив с тремя элементами типа string
$intArray = [1, 2, 3]; // массив с тремя элементами типа int
$mixedArray = [1, 'f', null]; // Массив с тремя элементами смещанного типа

```

Доступ к элементам массива получаем с помощью индекса 

```php
$array = ['a', 'b', 'c']; // обьявляем массив

echo $array[1]; // выводит 'b' потому что под индексом 0 находится 'a'

```
В процессе работы программы мы можем переопределять элементы массива по средствам доступа к определенным индексам

```php
$array = ['a', 'b', 'c']; // обьявляем массив

echo $array[2]; // 'c'

$array[2] = 'f'; // сейчас массив ['a', 'b', 'f'] поскольку мы заменили элеимент под индексом 2

echo $array[2]; // 'f'

```

Так же мы можем удалять элементы массива

```php
$array = ['a', 'b', 'c']; // обьявляем массив

unset($array[1]); // сейчас массив ['a', 'f']

```
![ничего не понял но очень интересно](images/nichegoneponyal.png)

Давайте теперь для работы с переменными использовтаь две сервисные функции [print_t](https://www.php.net/manual/ru/function.print-r.php) и [var_dump](https://www.php.net/manual/ru/function.var-dump.php)

Рассмотрим пример выше

```php
$array = ['a', 'b', 'c']; // обьявляем массив

/**
Array
(
    [0] => a
    [1] => b
    [2] => c
)
 */
print_r($array);

unset($array[1]); // сейчас массив ['a', 'f']

/**
Array
(
    [0] => a
    [2] => c
)
 */
print_r($array);
```
Хорошо, теперь четко видно что из массива удаляется один элемент вместе с индексом и при этом смещения индексов не происхлодит т/е/ при добавление еще одно элемента следующий индекс будет идти под номером 3

```php
$array = ['a', 'b', 'c']; // обьявляем массив

/**
Array
(
    [0] => a
    [1] => b
    [2] => c
)
 */
print_r($array);

unset($array[1]); // сейчас массив ['a', 'f']

/**
Array
(
    [0] => a
    [2] => c
)
 */
print_r($array);

$array[] = 'd'; // Динамическое добавление элемента в конец массива

/**
Array
(
    [0] => a
    [2] => c
    [3] => d
)
 */
print_r($array);

```

Как вы уже успели понять $var[] позволяет динамически добавлять неограниченное количество значение в конец массива без занния последнего индекса
Но что будет если мы укажем конкретный индекс?

```php

$array = ['a', 'b', 'c']; // обьявляем массив

/**
Array
(
    [0] => a
    [1] => b
    [2] => c
)
 */
print_r($array);

$array[] = 'd'; // Динамическое добавление элемента в конец массива

/**
Array
(
    [0] => a
    [1] => b
    [2] => c
    [3] => d
)
 */
print_r($array);

$array[10] = 'f'; // Динамическое добавление элемента c конкретным индексом

/**
Array
(
    [0] => a
    [1] => b
    [2] => c
    [3] => d
    [10] => f
)
 */
print_r($array);

$array[3] = 'f'; // а вот так произойдет замена так как элемент с индексом 3 существует

/**
Array
(
    [0] => a
    [1] => f
    [2] => c
    [3] => d
    [10] => f
)
 */
print_r($array);
```
Из чего мы можем сделать вывод что при указани конкретного индекса если он в массиве не существует то будет добавлени индекс с соотвествующим значением
а если существует - то произойдет перезапись элемента индексаю

## Ассоциативные массивы

Ассоциативный массив - массив в котором элменты массиво ассоциируется с ключами 

 ```php
 
$array = [
  'one' => 1,
  'two' => 2,
  'tree' => 3
];

/**
Array
(
    [one] => 1
    [two] => 2
    [tree] => 3
)
 */
print_r($array);

echo $array['one'] ; // 1 

```
С точки зрения работы с ассоциативным массивом, нет отличий от работы с ним как с нумерованным

Хорошо, а что будет если я попытаюсь динамически добавить элемент в конец такого массива?

![ostin](images/ostinrisk.jpeg)

 ```php
 
$array = [
  'one' => 1,
  'two' => 2,
  'tree' => 3
];

/**
Array
(
    [one] => 1
    [two] => 2
    [tree] => 3
)
 */
print_r($array);

$array[] = 7;

/**
Array
(
    [one] => 1
    [two] => 2
    [tree] => 3
    [0] => 7
)
 */
print_r($array);

```

![what](images/what.jpeg)

Да в случае динамического добавление элемента PHP он добавлет нумерованный индекс последнего элемента +1 при условии что там есть нумерованный индекс

## Многомерные массивы

Многомерные массивы представляют из себя "матрешку" где под каждым элментом массива может находится еще лдин массив

```php

$array = [
    [1, 2, 3],
    ['a', 'b', 'c']
];

/**
Array
(
    [0] => Array
        (
            [0] => 1
            [1] => 2
            [2] => 3
        )

    [1] => Array
        (
            [0] => a
            [1] => b
            [2] => c
        )

)
*/
print_r($array);

echo $array[0][0]; // 1
echo $array[1][2]; // c

```

## Функции для работы с массивами

В PHP достаточно много [функций для работы с массивами](https://www.php.net/manual/ru/ref.array.php)
но мы рассмотрим только некоторые  из них

### count

[count](https://www.php.net/manual/ru/function.count.php) — Подсчитывает количество элементов массива или Countable объекте(про обьекты мы погорим в рамках ООП)

```php

$array = [1, 2, ,3];

echo count($array); // 3

$arrayMix = [
    'one' => 1,
    'two' => [4, 5],
];

echo count($arrayMix); // 2
echo count($arrayMix['two']); // 2

```

### Implode & Explode

[explode](https://www.php.net/manual/ru/function.explode.php) — Разбивает строку с помощью разделителя
[implode](https://www.php.net/manual/ru/function.implode.php) - Объединяет элементы массива в строку

```php

$string = 'one, two, three';

$array = explode(',', $string);

/**
Array
(
    [0] => one
    [1] =>  two
    [2] =>  three
)
 */
print_r($array);

$newString = implode('|', $array);

echo $string; // one| two| three
```

### is_array

[is_array](https://www.php.net/manual/ru/function.is-array.php) — Определяет, является ли переменная массивом

```php

$var = '1';

is_array($var); // false

$var = [];

is_array($var); // true

```

### isset & array_key_exists

[isset](https://www.php.net/manual/ru/function.isset.php) — Определяет, была ли установлена переменная значением, отличным от null
[array_key_exists](https://www.php.net/manual/ru/function.array-key-exists.php) - Проверяет, присутствует ли в массиве указанный ключ или индекс

На самом деле isset работает с любыми переменными любого типа в отличчии от array_key_exists который работает только с массивами

```php

$array = ['one', 'two', null];

isset($array[0]); // true потому что существует и не null
array_key_exists(0, $array); // true  потому что ключ существует

isset($array[2]); // false потому что существует но значение null
array_key_exists(2, $array); // true  потому что ключ существует

```

![kaktak?](images/derzhisb.jpeg)

## Функции для работы с сортировками

На самостоятельно обучание

## Управляющая конструкция foreach

Конструкция foreach предоставляет простой способ перебора массивов. foreach работает только с массивами и объектами, и будет генерировать ошибку при попытке использования с переменными других типов или неинициализированными переменными. Существует два вида синтаксиса:

```
foreach (iterable_expression as $value)
    statement
foreach (iterable_expression as $key => $value)
    statement
```
Первый цикл перебирает массив, задаваемый с помощью iterable_expression. На каждой итерации значение текущего элемента присваивается переменной $value.

Второй цикл дополнительно присвоит ключ текущего элемента переменной $key на каждой итерации.

Обратите внимание, что foreach не изменяет указатель внутреннего массива, который используется такими функциями, как current() и key().

Возможно настроить итераторы объектов.

Для того, чтобы напрямую изменять элементы массива внутри цикла, переменной $value должен предшествовать знак &. В этом случае значение будет присвоено по ссылке.

Проще говоря foreach перебирает массивы(или обьекты типа iterable) любой длинный, сам зная где начало и конец массива

```php

$array = [1, 2, 3]

foreach ($array as $num) {
    echo $num; // 1, 2, 3
}

foreach ($array as $k => $v) {
    echo "$k => $v"; // 0 => 1, 1 => 2, 2 => 3
}

$newArray = [
    'one' => 1,
    'two' => ["hello", "there" ],
    'tree' => 3
];

foreach ($newArray as $key => $v) {
    if (is_array($v)) {
        foreach ($v as $k => $value) {
            echo "$k  $value"; // 0 hello, 1 there
        }
    } else {
        echo "$key => $v"; //one => 1, three => 3
    }
}
```

## ДЗ
1. Написать в виде массивов список а) Название фильмов по звездным войнам, б) места в кинотеатре, в) список оценок по предметам(предметы выбирайте сами)
2. Основываясь на #1 задании отсортировать массивы по определенным критериям(критерии выбирайте сами)
3. Написать функцию которая принимает первым аргументом массив и выводит все его элементы. Учтите что массив может быть многомерный
4. Написать функцию которая принимает два аргумента, первый массив а вторым значение для поиска. В случае если значение было найдено возвращает его ключ иначе false. пользоваться стандартной функцией для поиска в массиве нельзя. Учтите что массив может быть многомерный
5. Основывая на #4 задании написать ту же функцию но тепреь она работает рекурсивно
