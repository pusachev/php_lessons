# Строки, Циклы 

## Строки

Строка (тип string) - это набор символов, где символ - это то же самое, что и байт. Это значит, что PHP поддерживает ровно 256 различных символов, а также то, что в PHP нет встроенной поддержки Unicode

Строка может быть определена четырьмя различными способами:

- одинарными кавычками
- двойными кавычками
- heredoc-синтаксисом
- nowdoc-синтаксисом

### Одинарные кавычки 

Простейший способ определить строку - это заключить её в одинарные кавычки (символ ').

Чтобы использовать одинарную кавычку внутри строки, проэкранируйте её обратным слешем (\). Если необходимо написать сам обратный слеш, продублируйте его (\\). Все остальные случаи применения обратного слеша будут интерпретированы как обычные символы: это означает, что если вы попытаетесь использовать другие управляющие последовательности, такие как \r или \n, они будут выведены как есть вместо какого-либо особого поведения.

```php
<?php
echo 'это простая строка';

echo 'Также вы можете вставлять в строки
символ новой строки вот так,
это нормально';

// Выводит: Однажды Арнольд сказал: "I'll be back"
echo 'Однажды Арнольд сказал: "I\'ll be back"';

// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\\*.*?';

// Выводит: Вы удалили C:\*.*?
echo 'Вы удалили C:\*.*?';

// Выводит: Это не будет развёрнуто: \n новая строка
echo 'Это не будет развёрнуто: \n новая строка';

// Выводит: Переменные $expand также $either не разворачиваются
echo 'Переменные $expand также $either не разворачиваются';
```

### Двойные кавычки 

Если строка заключена в двойные кавычки ("), PHP распознает следующие управляющие последовательности специальных символов:

- **\n**	новая строка (LF или 0x0A (10) в ASCII)
- **\r**	возврат каретки (CR или 0x0D (13) в ASCII)
- **\t**	горизонтальная табуляция (HT или 0x09 (9) в ASCII)
- **\v**	вертикальная табуляция (VT или 0x0B (11) в ASCII)
- **\e**	escape-знак (ESC или 0x1B (27) в ASCII)
- **\f**	подача страницы (FF или 0x0C (12) в ASCII)
- **\\**	обратная косая черта
- **\$**	знак доллара
- **\"**	двойная кавычка
- **\[0-7]{1,3}**	последовательность символов, соответствующая регулярному выражению символа в восьмеричной системе счисления, который молча переполняется, чтобы поместиться в байт (т.е. "\400" === "\000")
- **\x[0-9A-Fa-f]{1,2}**	последовательность символов, соответствующая регулярному выражению символа в шестнадцатеричной системе счисления
- **\u{[0-9A-Fa-f]+}**	последовательность символов, соответствующая регулярному выражению символа Unicode, которая отображается в строка в представлении UTF-8

Как и в строке, заключённой в одинарные кавычки, экранирование любого другого символа выведет также и сам символ экранирования.

Но самым важным свойством строк в двойных кавычках является обработка переменных.

```php
<?php

$string = "Привет я строка";
$stringWithSpecial = "Привет я строка \n с переносом строки";
$stringWithVariable = "Привет я строка в которой есть переменная $string";
```
> Процесс "подстановки" значения перемнных в двойных кавычках, называется интерполяция

### Heredoc

Третий способ определения строк - это использование heredoc-синтаксиса: <<<. После этого оператора необходимо указать идентификатор, затем перевод строки. После этого идёт сама строка, а потом этот же идентификатор, закрывающий вставку.

Закрывающий идентификатор может иметь отступ с помощью пробела или табуляции, и в этом случае отступ будет удалён из всех строк в строке документа. До PHP 7.3.0 закрывающий идентификатор должен был находиться в самом начале новой строки.

Кроме того, закрывающий идентификатор должен соответствовать тем же правилам именования, что и любая другая метка в PHP: он должен содержать только буквенно-цифровые символы и подчёркивания и должен начинаться с нецифрового символа или символа подчёркивания.

```php 
<?php
// без отступов
echo <<<END
      a
     b
    c
\n
END;

// 4 отступа
echo <<<END
      a
     b
    c
    END;
```
Если закрывающий идентификатор смещён дальше, чем любая строка тела, будет выброшено ParseError:

```php 
<?php
echo <<<END
  a
 b
c
   END;
```

Результат выполнения данного примера в PHP 7.3:

PHP Parse error:  Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4

### Nowdoc

Nowdoc - это то же самое для строк в одинарных кавычках, что и heredoc для строк в двойных кавычках. Nowdoc похож на heredoc, но внутри него не осуществляется никаких подстановок. Эта конструкция идеальна для внедрения PHP-кода или других больших блоков текста без необходимости его экранирования. В этом он немного похож на SGML-конструкцию <![CDATA[ ]]> тем, что объявляет блок текста, не предназначенный для обработки.

Nowdoc указывается той же последовательностью <<<, что используется в heredoc, но последующий за ней идентификатор заключается в одинарные кавычки, например, <<<'EOT'. Все условия, действующие для идентификаторов heredoc также действительны и для nowdoc, особенно те, что относятся к закрывающему идентификатору.

```php 
<?php
echo <<<'EOD'
Пример текста,
занимающего несколько строк,
с помощью синтаксиса nowdoc. Обратные слеши всегда обрабатываются буквально,
например, \\ и \'.
EOD;
```

Результат выполнения данного примера:

>Пример текста,
>занимающего несколько строк,
>с помощью синтаксиса nowdoc. Обратные слеши всегда обрабатываются буквально,
>например, \\ и \'.

### Обработка переменных

Если строка указывается в двойных кавычках, либо при помощи heredoc, переменные внутри неё обрабатываются.

Существует два типа синтаксиса: простой и сложный. Простой синтаксис более лёгок и удобен. Он даёт возможность обработки переменной, значения массива (array) или свойства объекта (object) с минимумом усилий.

Сложный синтаксис может быть определён по фигурным скобкам, окружающим выражение.

#### Простой синтаксис

Если интерпретатор встречает знак доллара ($), он захватывает так много символов, сколько возможно, чтобы сформировать правильное имя переменной. Если вы хотите точно определить конец имени, заключайте имя переменной в фигурные скобки.

```php 
<?php
$juice = "apple";

echo "He drank some $juice juice.".PHP_EOL;

// Некорректно. 's' - верный символ для имени переменной, но переменная имеет имя $juice.
echo "He drank some juice made of $juices.";

// Корректно. Строго указан конец имени переменной с помощью скобок:
echo "He drank some juice made of ${juice}s.";
```
Результат выполнения данного примера:

>He drank some apple juice.
> 
>He drank some juice made of .
> 
>He drank some juice made of apples.

Аналогично могут быть обработаны элемент массива (array) или свойство объекта (object). В индексах массива закрывающая квадратная скобка (]) обозначает конец определения индекса. Для свойств объекта применяются те же правила, что и для простых переменных.

```php 
?php
define('KOOLAID', 'koolaid1');
$juices = array("apple", "orange", "koolaid1" => "purple");

echo "He drank some $juices[0] juice.".PHP_EOL;
echo "He drank some $juices[1] juice.".PHP_EOL;
echo "He drank some $juices[koolaid1] juice.".PHP_EOL;

class people {
    public $john = "John Smith";
    public $jane = "Jane Smith";
    public $robert = "Robert Paulsen";

    public $smith = "Smith";
}

$people = new people();

echo "$people->john drank some $juices[0] juice.".PHP_EOL;
echo "$people->john then said hello to $people->jane.".PHP_EOL;
echo "$people->john's wife greeted $people->robert.".PHP_EOL;
echo "$people->robert greeted the two $people->smiths."; // Не сработает
```

>He drank some apple juice.
> 
>He drank some orange juice.
> 
>He drank some purple juice.
> 
>John Smith drank some apple juice.
> 
>John Smith then said hello to Jane Smith.
> 
>John Smith's wife greeted Robert Paulsen.
> 
>Robert Paulsen greeted the two .

#### Сложный (фигурный) синтаксис

Он называется сложным не потому, что труден в понимании, а потому что позволяет использовать сложные выражения.

Любая скалярная переменная, элемент массива или свойство объекта, отображаемое в строку, может быть представлена в строке этим синтаксисом. Выражение записывается так же, как и вне строки, а затем заключается в { и }. Поскольку { не может быть экранирован, этот синтаксис будет распознаваться только когда $ следует непосредственно за {. Используйте {\$, чтобы напечатать {$. Несколько поясняющих примеров:

```php 
<?php
// Показываем все ошибки
error_reporting(E_ALL);

$great = 'здорово';

// Не работает, выводит: Это { здорово}
echo "Это { $great}";

// Работает, выводит: Это здорово
echo "Это {$great}";

// Работает
echo "Этот квадрат шириной {$square->width}00 сантиметров.";

// Работает, ключи, заключённые в кавычки, работают только с синтаксисом фигурных скобок
echo "Это работает: {$arr['key']}";

// Работает
echo "Это работает: {$arr[4][3]}";

// Это неверно по той же причине, что и $foo[bar] вне
// строки. Другими словами, это по-прежнему будет работать,
// но поскольку PHP сначала ищет константу foo, это вызовет
// ошибку уровня E_NOTICE (неопределённая константа).
echo "Это неправильно: {$arr[foo][3]}";

// Работает. При использовании многомерных массивов внутри
// строк всегда используйте фигурные скобки
echo "Это работает: {$arr['foo'][3]}";

// Работает.
echo "Это работает: " . $arr['foo'][3];

echo "Это тоже работает: {$obj->values[3]->name}";

echo "Это значение переменной по имени $name: {${$name}}";

echo "Это значение переменной по имени, которое возвращает функция getName(): {${getName()}}";

echo "Это значение переменной по имени, которое возвращает \$object->getName(): {${$object->getName()}}";

// Не работает, выводит: Это то, что возвращает getName(): {getName()}
echo "Это то, что возвращает getName(): {getName()}";

// Не работает, выводит: C:\folder\{fantastic}.txt
echo "C:\folder\{$great}.txt"

// Работает, выводит: C:\folder\fantastic.txt
echo "C:\\folder\\{$great}.txt"
```
## Работа со строками

### Конкатенация

В PHP есть два оператора для работы со строками (string). Первый - оператор конкатенации ('.'), который возвращает строку, представляющую собой соединение левого и правого аргумента. Второй - оператор присваивания с конкатенацией ('.='), который присоединяет правый аргумент к левому. Для получения более полной информации ознакомьтесь с разделом

```php 
<?php
$a = "Привет, ";
$b = $a . "Мир!"; // $b теперь содержит строку "Привет, Мир!"

$a = "Привет, ";
$a .= "Мир!";     // $a теперь содержит строку "Привет, Мир!"
```

### Работа со строками

#### Поииск символа в строке

strpos — Возвращает позицию первого вхождения подстроки

```php 
<?php
$mystring = 'abc';
$findme   = 'a';
$pos = strpos($mystring, $findme);

// Заметьте, что используется ===.  Использование == не даст верного
// результата, так как 'a' находится в нулевой позиции.
if ($pos === false) {
    echo "Строка '$findme' не найдена в строке '$mystring'";
} else {
    echo "Строка '$findme' найдена в строке '$mystring'";
    echo " в позиции $pos";
}
```
```php 
<?php
// Можно искать символ, игнорируя символы до определённого смещения
$newstring = 'abcdef abcdef';
$pos = strpos($newstring, 'a', 1); // $pos = 7, не 0
```

> Эта функция может возвращать как логическое значение false, так и значение не типа boolean, которое приводится к false. За более подробной информацией обратитесь к разделу Булев тип. Используйте оператор === для проверки значения, возвращаемого этой функцией.

#### Замена символа в строке

str_replace — Заменяет все вхождения строки поиска на строку замены

```php 
<?php
// присваивает <body text='black'>
$bodytag = str_replace("%body%", "black", "<body text='%body%'>");

// присваивает: Hll Wrld f PHP
$vowels = array("a", "e", "i", "o", "u", "A", "E", "I", "O", "U");
$onlyconsonants = str_replace($vowels, "", "Hello World of PHP");

// присваивает: You should eat pizza, beer, and ice cream every day
$phrase  = "You should eat fruits, vegetables, and fiber every day.";
$healthy = array("fruits", "vegetables", "fiber");
$yummy   = array("pizza", "beer", "ice cream");

$newphrase = str_replace($healthy, $yummy, $phrase);

// присваивает: 2
$str = str_replace("ll", "", "good golly miss molly!", $count);
echo $count;
```

#### Функции работы со строками

Больше функций можно найти в [офф документации](https://www.php.net/manual/ru/ref.strings.php)

## Циклы

Циклы один из важнейших инструментов управления в ЯП
С помощь цыклов можно существенно уменьшить количество кода для однотипных операций(например посчет чисел от 1 до 20)
Циклы делятся на цыклы с пред условием и пост условием.
Циклы с пред условием сначала проверяют условие и если оно истино то выполняют итерацию и так пока условие не станет ложным
Циклы с пост условие сначала выполняют итерацию, а потом проверяют истиность условия. Такие циклы гарантируют что как минимум одна итерация точно прроизойдет не зависимо от того условие истини или ложно.

### For

Цикл for самый сложный цикл в PHP. Он ведёт себя так же, как и в языке C. Синтаксис цикла for следующий:

for (expr1; expr2; expr3)
statement
Первое выражение (expr1) всегда вычисляется (выполняется) только один раз в начале цикла.

В начале каждой итерации оценивается выражение expr2. Если оно принимает значение true, то цикл продолжается и выполняются вложенные операторы. Если оно принимает значение false, выполнение цикла заканчивается.

В конце каждой итерации выражение expr3 вычисляется (выполняется).

Каждое из выражений может быть пустым или содержать несколько выражений, разделённых запятыми. В expr2 все выражения, разделённые запятыми, вычисляются, но результат берётся из последнего. Если выражение expr2 отсутствует, это означает, что цикл будет выполняться бесконечно. (PHP неявно воспринимает это значение как true, так же, как в языке C). Это может быть не так бесполезно, как вы могли подумать, так как часто необходимо прервать цикл, используя условный оператор break вместо использования выражения в цикле for, которое принимает истинное значение.

Рассмотрим следующие примеры. Все они отображают числа от 1 до 10:

```php 
<?php
/* пример 1 */

for ($i = 1; $i <= 10; $i++) {
    echo $i;
}

/* пример 2 */

for ($i = 1; ; $i++) {
    if ($i > 10) {
        break;
    }
    echo $i;
}

/* пример 3 */

$i = 1;
for (; ; ) {
    if ($i > 10) {
        break;
    }
    echo $i;
    $i++;
}

```

### While

Циклы while являются простейшим видом циклов в PHP. Они ведут себя так же, как и в языке C. Простейшей формой цикла while является следующее выражение:

while (expr)
statement
Смысл выражения while очень прост. Оно указывает PHP выполнять вложенные выражения повторно до тех пор, пока выражение в самом while является true. Значение выражения expr проверяется каждый раз перед началом цикла, поэтому даже если значение выражения изменится в процессе выполнения вложенных выражений в цикле, выполнение не прекратится до конца итерации (каждый раз, когда PHP выполняет выражения в цикле - это одна итерация). Если выражение while равно false с самого начала, вложенные выражения ни разу не будут выполнены.

Также, как и с оператором if, вы можете группировать несколько выражений внутри одного цикла while, заключая эти выражения между фигурными скобками или используя альтернативный синтаксис:

while (expr):
statement
...
endwhile;
Следующие примеры идентичны, и оба выведут числа от 1 до 10:

```php 
<?php
/* пример 1 */

$i = 1;
while ($i <= 10) {
    echo $i++;  /* выводиться будет значение переменной
                   $i перед её увеличением
                   (post-increment) */
}

/* пример 2 */

$i = 1;
while ($i <= 10):
    echo $i;
    $i++;
endwhile;
```

### do while

Цикл do-while очень похож на цикл while, с тем отличием, что истинность выражения проверяется в конце итерации, а не в начале. Главное отличие от обычного цикла while в том, что первая итерация цикла do-while гарантированно выполнится (истинность выражения проверяется в конце итерации), тогда как она может не выполниться в обычном цикле while (истинность выражения которого проверяется в начале выполнения каждой итерации, и если изначально имеет значение false, то выполнение цикла будет прервано сразу).

Есть только один вариант синтаксиса цикла do-while:

```php 
<?php
$i = 0;
do {
    echo $i;
} while ($i > 0);
```

В примере цикл будет выполнен ровно один раз, так как после первой итерации, когда проверяется истинность выражения, она будет вычислена как false ($i не больше 0) и выполнение цикла прекратится.

Опытные пользователи С могут быть знакомы с другим использованием цикла do-while, которое позволяет остановить выполнение хода программы в середине блока, для этого нужно обернуть нужный блок кода вызовом do-while (0) и использовать break. Следующий фрагмент кода демонстрирует этот подход:

```php 
<?php
do {
    if ($i < 5) {
        echo "i ещё недостаточно велико";
        break;
    }
    $i *= $factor;
    if ($i < $minimum_limit) {
        break;
    }
   echo "значение i уже подходит";

    /* обработка i */

} while (0);
```

## ДЗ

1. Написать функцию которая принимает на первым аргументом строку, а вторым символ. В случае если искомые символ присуствует в строке то заменить его встроке на такой же но в верхнем регистре
2. Написать функцию которая принимает первым аргументом строку, вторым символ. С помощью цикла вывести данный симфол столько раз сколько симфолов в строке переданной в первом аргументе
3. Написать функцию которая первым аргументом принимает символ(по умолчанию #) и число(по умолчанию 5) после чего рисует пирамиду следующего вида:
```
 #
 ##
 ###
 ####
 ##### 
 ```
Где второй аргумент это одновременно и количество рядов и количество печатаемых символов
4. (*)Написать функцию котоая принимает аргументом строку и возвращает ее перевернутый вариант(пример, "Test" -> "tseT") использовать стандартные функции php работы со строкаими нельзя
5. (*) Написать функцию которая на вход получает строку(пароль) и проверяет сложность пароля по шкале Простой, Нормальный, Сложный
6. (*) написать функцию которая на вход примниает два аргумента - строки(отрывки из текста) и сравнивает % совпадения. Если строки идентичны - 100%